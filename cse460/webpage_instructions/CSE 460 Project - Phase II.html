<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"> <title>CSE 460 Project - Phase II</title> </head>
<body>

<h2>Project - Phase II: Process Management</h2>
<h3>
CSE 460: Operating Systems
<br>
Spring 2016, Zemoudeh
<br>
School of Computer Science and Engineering
<br>
California State University, San Bernardino
</h3>

<br>

<p>
In this phase we will add
process management layer to our OS,
and convert the single-user OS of phase I to
a time-sharing OS in this phase.
Under your home directory create <code>cse460</code> directory, under that directory create directories
 <code>phase1</code>
 and <code>phase2</code>.
Copy all your code and data from phase I to both <code>phase1</code>
 and <code>phase2</code>.
Modify, implement, and run the new version of the OS
in <code>phase2</code> directory without changing your old code in phase I.

</p><p>
In this phase every program consists of 5 files with
the same name but different suffixes: <code>.s, .o, .in, .out,</code> and <code>.st.</code> For example, the factorial
program consists of <code>fact.s, fact.o, fact.in, fact.out,</code> and <code>fact.st.</code> 
<code>*.s</code> and <code>*.in</code>
files, which contain the assembly program and its input respectively,
must exist before starting the OS. 
<code>*.o</code> file is generated by the OS for each <code>*.s</code> file
through a call to the assembler.
<code>*.out</code> file is created by the OS and contains output of the
program. <code>*.st</code> file is an input/output file and contains the stack of a process when 
it's not running.
Only one stack at a time resides in memory.
When a process is running on VM, its stack is read into
high memory from its <code>*.st</code> file; and when the process relinquishes VM,
its stack
is written onto its <code>*.st</code> file.

</p><p>
By examining the value of <code>sp</code> register, OS can tell whether
the content of stack in memory has to be saved in <code>*.st</code> file.
When a process relinquishes VM and <code>sp = 256</code> in VM, there is no stack and therefore there is nothing to save.
Otherwise, when <code>sp &lt; 256</code>, there is a stack and its content must be saved for future restart.
Analogously, when a process is assigned to the VM, if <code>sp</code> in its PCB is less than 256 then it has
a stack and it needs to be loaded from its <code>*.st</code> file into memory. 
Remove <code>*.st</code> file when its corresponding process halts.

</p><p>
When the OS comes up it looks in 
current directory and gathers all <code>*.s</code> files:

</p><pre>     system("ls *.s &gt; progs");
</pre>

It then opens <code>progs</code> and reads in file names.
Each file is  assembled, its object code loaded
in memory, and a pointer to its PCB is stored in a linked-list:

<pre>     list&lt;PCB *&gt; jobs;
     PCB * p = new PCB;
     jobs.push_back(p);
</pre>

In this phase of the project degree of multiprogramming is the same as
number of <code>*.s</code> files in the current directory (in <code>progs</code>).
The processes are resident in memory
until OS halts. The processes (PCBs) are either in ready, waiting,
or running state. Maintain two queue of processes, Ready Queue and Wait Queue,
of type pointer to PCB:

<pre>     queue&lt;PCB *&gt; readyQ, waitQ;
</pre>

The running process is also represented by a pointer to its PCB:

<pre>     PCB * running;
</pre>

Pointers in <code>readyQ, waitQ,</code> and <code>running</code> point to a PCB in
the linked-list of PCBs (<code>jobs</code>).
Initially all processes are pushed on <code>readyQ</code>. To execute the very first process,
the pointer to the process in front of <code>readyQ</code> is popped and assigned to <code>running</code> and the process is assigned to VM and starts running.
Usually two conditions force a running process to relinquish VM: 
either the process
completes its time slice, when it will be added to end of <code>readyQ</code>;
or it executes an I/O operation (<code>read</code> or <code>write</code> instruction),
when it will be added to end of <code>waitQ</code>. There are also other
 conditions that cause VM to return.
As a result, the VM returns to the OS with a return status indicating 
which condition occurred. The complete list of return-statuses is:
<br>
<br>
a. overflow
<br>
b. time slice
<br>
c. <code>halt</code> instruction
<br>
d. out-of-bound reference
<br>
e. stack overflow
<br>
f. stack underflow
<br>
g. invalid opcode
<br>
h. I/O operation
<br>
<br>
VM sets the status register based on the above conditions and OS examines it to know how the previous process
relinquished VM. In this phase, the format of the <code>sr</code> register is modified to include VM Return-status encoded in 3 bits:

<p>

<style type="text/css">
table.sample1 {
	border-width: 0px;
	border-spacing: ;
	border-style: outset;
	border-color: gray;
	border-collapse: collapse;
	background-color: white;
}
table.sample1 th {
	border-width: 1px;
	padding: 1px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
table.sample1 td {
	border-width: 0px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
</style>
<table class="sample1">
<tbody><tr>
<th> &nbsp; d &nbsp; </th>
<th> &nbsp; ... &nbsp; </th>
<th> &nbsp; d &nbsp; </th>
<th> &nbsp; I/O Register &nbsp; </th>
<th> &nbsp; VM Return-status &nbsp; </th>
<th> &nbsp; V &nbsp; </th>
<th> &nbsp; L &nbsp; </th>
<th> &nbsp; E &nbsp; </th>
<th> &nbsp; G &nbsp; </th>
<th> &nbsp; C &nbsp; </th>
</tr>
<tr>
<td> &nbsp; 15  </td>
<td> &nbsp; </td>
<td> &nbsp; 10  </td>
<td> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9:8  </td>
<td> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7:5  </td>
<td> &nbsp; 4  </td>
<td> &nbsp; 3  </td>
<td> &nbsp; 2  </td>
<td> &nbsp; 1  </td>
<td> &nbsp; 0  </td>
</tr>
</tbody></table>

Meaning of VM return status in <code>sr</code> (contained in bits 7:5) is summarized in the following table:
</p><p>
<table>
<tbody><tr> <td> <strong> VM Return-status </strong></td><td> <strong> &nbsp; Meaning
</strong></td></tr><tr> <td> 000 </td><td> &nbsp; Time slice
</td></tr><tr> <td> 001 </td><td> &nbsp; Halt Instruction
</td></tr><tr> <td> 010 </td><td> &nbsp; Out-of-bound Reference
</td></tr><tr> <td> 011 </td><td> &nbsp; Stack Overflow
</td></tr><tr> <td> 100 </td><td> &nbsp; Stack Underflow
</td></tr><tr> <td> 101 </td><td> &nbsp; Invalid Opcode
</td></tr><tr> <td> 110 </td><td> &nbsp; Read Operation
</td></tr><tr> <td> 111 </td><td> &nbsp; Write Operation
</td></tr></tbody></table>

</p><p>
In case of Read/Write (I/O) operations, the destination register is 
specified in bits 9:8. The OS needs to know which register was
the target of the I/O operation. For example, if the instruction was

</p><pre>     read 2
</pre>

the VM passes 2 = 10<sub>2</sub> in bits 9:8 (of <code>sr</code>) to the OS, and it's the responsibility of the OS to read the
content of register 2 (from the <code>.in</code> file) into the PCB.
Now when the process is ready to resume, the content of register 2 is ready and will be transferred to the VM. 


<p>
Any time the VM returns (one of the above eight conditions has occurred or overflow bit has been set) a context switch
happens and scheduler reorganizes the queues.
Context switch takes 5 clock ticks (all CPU time). During this time
<br>
<b>first,</b> all processes in <code>waitQ</code> whose I/O operation has been completed
are placed in <code>readyQ</code>,
<br>
<b>second</b> the running process is placed in the proper queue or terminated,
and 
<br>
<b>third</b> the next process from <code>readyQ</code> is assigned to VM (CPU).

</p><p>
I/O requests could immediately occur in the PCB: when an I/O operations is encountered,
immediately perform the I/O (<code>read</code> or <code>write</code> instruction)
in PCB, move the PCB to <code>waitQ</code>, and set the interrupt
(I/O completion) time to <code>clock + 28</code>. During the next
context switch, if the I/O completion time of a process in <code>waitQ</code> is less than or equal to the current time
(the I/O interrupt has arrived),
its PCB is moved to <code>readyQ</code>.
If all processes are waiting on I/O (<code>readyQ</code> is empty),
you must add as many clock ticks to the clock 
to match the completion time of the earliest I/O request, at which point
that process will be ready for execution and is moved to <code>readyQ</code> and then to running state.
This is counted as idle time and decreases CPU utilization, see below.

</p><p>
If time slice of a process is over in the middle of <code>load</code>,
<code>store</code>,
<code>call</code>, and
<code>return</code> instructions,
finish the instruction first and then perform context switch.
Any time this occurs,
effectively the time slice of the process is extended by at
most 3 clock ticks.

</p><p>
All memory references made by a process have to be
checked against its <code>base</code> and <code>limit</code> values. If an out-of-bound reference
is made, the program is terminated and an appropriate message must appear in the <code>.out</code> file.
Note all addresses are offset from <code>base</code>;
at run time add <code>base</code> value to the addresses in
<code>load</code>,
<code>store</code>,
<code>call</code>,
and <code>jump</code> instructions.

</p><p>
Each PCB should at least include <code>pc</code>, <code>r[0]-r[3]</code>, <code>sr</code>,
<code>sp</code>, <code>base</code>, <code>limit</code>, process name, 
<code>fstream</code>s associated with the <code>*.o</code>, <code>*.in</code>, <code>*.out</code>,
and <code>*.st</code> files, and the following 
accounting information: VM (CPU) Time, Waiting Time, Turnaround Time,
I/O Time, and the Largest Stack Size.
The accounting information for each process must appear
at end of the <code>*.out</code> file.
Also VM Utilization and Throughput must appear
at end of EACH <code>*.out</code> file after the process
specific accounting information.

</p><p>
The definitions of the accounting information as they pertain to 
this phase are:

</p><p>
<strong>Process Specific:</strong>

<br>
CPU Time: number of clock ticks a process executes in CPU.
(<code>read</code> and <code>write</code> each take 1 CPU clock tick and 27 I/O clock ticks.)

<br>
Waiting Time: number of clock ticks spent in <code>readyQ</code>.

<br>
Turnaround Time: time up to and including the <code>halt</code> instruction execution.

<br>
I/O Time: number of clock ticks spent in <code>waitQ</code>.

<br>
Largest Stack Size: largest number of memory locations allocated to the stack.

</p><p>
<strong>System Information:</strong>

<br>
System Time = sum of all Context Switch Times and Idle Times

<br>
System CPU Utilization: percent of time CPU is busy = (final clock - sum of all Idle Times) / final clock

<br>
User CPU Utilization: percent of the time CPU executes user jobs = (sum of all jobs' CPU time) / final clock

<br>
Throughput: number of processes completed per second. Assume 1 second = 1000 clock ticks.

</p><p>
The following table summarizes all times.

</p><p>
<style type="text/css">
table.sample {
	border-width: 1px;
	border-spacing: ;
	border-style: outset;
	border-color: gray;
	border-collapse: collapse;
	background-color: white;
}
table.sample th {
	border-width: 1px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
table.sample td {
	border-width: 1px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
</style>

<table class="sample">
<tbody><tr> <th> load/store instr </th><th> call/return instr </th><th> read/write instr </th><th> all other instr </th><th> time slice     </th><th> context switch </th><th> 1 second </th></tr>
<tr> <td> 4 clock ticks    </td><td> 4 clock ticks     </td><td> 28 clock ticks   </td><td> 1 clock tick    </td><td> 15 clock ticks </td><td> 5 clock ticks </td><td> 1000 ticks </td></tr>
</tbody></table>

</p><p>
Make <code>OS</code> class a <code>friend</code> of <code>VirtualMachine</code> class
so that for each process the state of the VM
can be loaded from or stored to its PCB by the OS.

</p><p>
Run your OS for 6 programs as follows:

<br>
(From phase I) <code>fact1.s</code> with input 6 (<code>fact1.in</code> contains 6)

<br>
(From phase I) <code>fact2.s</code> with input 8 (<code>fact2.in</code> contains 8)

<br>
(From phase I) <code>sub.s</code> (subtract 2 program) 

<br>
<code>sum1.s</code> with input 50 (<code>sum1.in</code> contains 50)

<br>
<code>sum2.s</code> with input 101 (<code>sum2.in</code> contains 101)

<br>
<code>io.s</code> where <code>io.in</code> contains 0 1 2 3 4 5 6 7 8 9 10 11

</p><p>
The <code>sum</code> program is as follows:

</p><pre>    loadi  0 1   ! i = 1
    loadi  1 0   ! sum = 0
    read   2
    compr  0 2
    jumpe  8     ! done
    add    1 0   ! sum += i
    addi   0 1   ! i++
    jump   3     ! loop again
    write  1
    halt
</pre>

The <code>io.s</code> program is as follows:

<pre>    loadi  0 0   ! i = 0
    compri 0 6   ! 6 pairs to read
    jumpe  9     ! i == 6 done
    read   1
    read   2
    add    1 2
    write  1
    addi   0 1   ! i++
    jump   1     ! loop again
    halt
</pre>

Implement your program incrementally. 
<br>
First, modify your OS to
run only two programs without
any I/O (just compute intensive <code>.s</code> programs).
<br>
Second, modify your OS to handle programs with I/O.
<br>
Third, try several compute
and I/O intensive programs.
<br>
Fourth, modify your OS to gather accounting information.
<br>
Fifth, modify your OS to handle programs with subroutine calls (which grow
stack).

<p>
Demonstrate your program and
hand in printouts of your source code
including OS, new VM and assembler, and all <code>*.s</code>,
<code>*.o</code>, <code>*.in</code>, and <code>*.out</code> files.
</p><p>
Same grading criteria as phase I holds.


</p></body></html>